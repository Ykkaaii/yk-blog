---
title: 常用排序算法学习笔记
author: 阿楷
date: 2022-03-31
categories:
 - 笔记
tags:
 - 算法
---

## 什么是算法

算法（Algorithm）**是指解题方案的准确而完整的描述**，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的**输入**，在**有限个步骤**获得所要求的**输出**。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。**一个算法的优劣可以用空间复杂度与时间复杂度来衡量**

### 一个算法应该具有以下五个重要的特征

- **可行性**: 算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤
- **有穷性**: 指算法必须能在执行有限个步骤之后终止
- **确切性**: 算法的每一步骤必须有确切的定义
- **输入项**: 有一定规范输入
- **输出项**: 有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的

<br>

### 衡量算法优劣可以从五个重要的特征

- **时间复杂度**: 指执行算法所需要的计算工作量
- **空间复杂度**: 指算法需要消耗的内存空间
- **正确性**: 指算法能否给出正确的结果
- **可读性**: 指一个算法可供人们阅读的容易程度
- **容错性**: 指一个算法对不合理数据输入的反应能力和处理能力

其中**时间复杂度**和**空间复杂度**也是衡量**算法性能**的重要指标

### 简单认识一下算法

算法（Algorithm），是指解题方案的**准确**而**完整**的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。

算法具有的五个特征：

* 有穷性：算法的有穷性是指算法必须能在执行**有限个步骤之后终止**；
* 确切性：**算法的每一步骤必须有确切的定义**；
* 输入项：**一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；**
* 输出项：**一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；**
* 可行性：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）。

### 算法优劣的评定
同一问题可用不同算法解决，不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用**空间复杂度**与**时间复杂度**来衡量。

#### 时间复杂度
算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模的函数，算法的时间复杂度也因此记做：t(n) = O(f(n))；
因此，问题的规模越大，算法执行的时间的增长率与的增长率正相关，称作渐进时间复杂度（Asymptotic Time Complexity）
#### 空间复杂度
算法的空间复杂度是指算法需要消耗的内存空间。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多
#### 正确性
算法的正确性是评价一个算法优劣的最重要的标准
#### 可读性
算法的可读性是指一个算法可供人们阅读的容易程度
#### 容错性
容错性是指一个算法对不合理数据输入的反应能力和处理能力，也称为鲁棒性


### 什么是稳定排序
待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中Ri领先于Rj, 若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的

比如int数组[1,1,1,6,4]中a[0],a[1],a[2]的值相等，在排序时不改变其序列，则称所用的方法是稳定的。


### 几种常见的排序算法

* 冒泡排序
* 选择排序
* 插入排序
* 希尔排序
* 快速排序

## 冒泡排序

冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。

它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。

这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。

### 冒泡排序算法的原理
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数
3. 针对所有的元素重复以上的步骤，除了最后一个
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较


### 冒泡排序的时间复杂度
若文件的初始状态是正序的，**一趟**扫描且**不需要进行移动**即可完成排序。所需的比较次数为n - 1, 交换次数为0
所以，冒泡排序最好的时间复杂度为 O(n)。

若初始文件是反序的，需要进行 n - 1 趟排序。每趟排序要进行 n - i 次关键字的比较(1 ≤ i(躺数) ≤ n-1)。每次比较都需要进行位置交换。在这种情况下，所需的比较次数为(n(n - 1))/2, 交换次数为(n(n - 1))/2

(n - 1) + (n - 2) + ···· + 2 + 1 = (n - 1)/2 * (n - 1 + 1) = (n(n - 1))/2

冒泡排序的最坏时间复杂度为 O(n^2)
综上，因此冒泡排序总的平均时间复杂度为 O(n^2)


### 冒泡排序的优化
使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序
## 选择排序

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法

### 选择排序算法的原理
选择排序需要两层循环来实现，外层循环控制次数，内层循环控制找到最小的值。然后将内层循环找到的最小值与外层循环本次索引对应元素进行交换，直至遍历完整个数组。


### 选择排序的时间复杂度
若文件的初始状态是正序的，**n - 1趟**扫描且不需要进行移动即可完成排序。所需的比较次数为n - 1, 交换次数为0
所以，选择排序最好的时间复杂度为 O(n)。

若初始文件是反序的，需要进行 n - 1 趟排序。每趟排序要进行 n - i 次关键字的比较(1 ≤ i(躺数) ≤ n-1)，每次比较只需要进行一次位置交换。在这种情况下，所需的比较次数为(n(n - 1))/2, 交换次数为n - 1

选择排序的最坏时间复杂度为 O(n^2)
综上，选择排序的平均时间复杂度为 O(n^2) **但是， 由于交换次数的时间复杂度记为O(n)，选择排序的效率比冒泡排序要快**

## 插入排序

插入排序（Insertion sort）一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法 。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动

### 插入排序算法的原理
插入排序是指在待排序的元素中，假设前面n-1(其中n>=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序 。


### 插入排序的时间复杂度
若文件的初始状态是正序的，**n - 1趟**扫描且不需要进行移动即可完成排序。所需的比较次数为n - 1, 交换次数为0
所以，插入排序最好的时间复杂度为 O(n)。

若初始文件是反序的，需要进行 n - 1 趟排序。每趟排序要进行 n - i 次关键字的比较(1 ≤ i(躺数) ≤ n-1)，每次比较只需要进行一次位置交换。在这种情况下，所需的比较次数为(n(n - 1))/2, 交换次数为(n(n - 1))/2 + n - 1

插入排序的最坏时间复杂度为 O(n^2)
综上，插入排序的平均时间复杂度为 O(n^2)

### 对比插入排序与选择排序


* 插入排序：
```js
for (let i = 1; i < len; i++) {
  const temp = list[i];
  let inner = i;
  while (inner > 0 && list[inner - 1] > temp) {
    list[inner] = list[inner - 1];
    inner--;
    n++;
    m++;
  }
  list[inner] = temp;
  m++;
}
```

* 选择排序：
```js
for (let i = 0; i < len; i++) {
  let min = i;
  for (let j = i + 1; j < len; j++) {
    // 计数
    n++;
    if (list[min] > list[j]) min = j;
  }

  m++;
  list[i] = [list[min], (list[min] = list[i])][0];
}
```

对比两段代码，内部循环体是有差别的：
* 选择排序无论什么情况都会进行遍历
* 插入排序只要是当前位置的值是最大的就不继续往前遍历，减少了比较的次数，当这个排序是部分有序的时候，插入排序的比较次数会大大减小

这个就是为什么**选择排序**和**插入排序**的时间复杂度都是O(n^2)但是插入排序的效率更高的原因



## 希尔排序

希尔排序(Shell's Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是**插入排序算法的一种更高效的改进版本**。希尔排序是非稳定排序算法。该方法因 D.L.Shell 于 1959 年提出而得名。

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止

::: tip 希尔排序稳定性
由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的。
:::

### 对比直接插入排序

直接插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如`[5,4,3,2,1,0]`这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。

而希尔排序在数组中采用**跳跃式分组**的策略，通过某个**增量**将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。

**希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后**。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。


### 希尔排序的核心

希尔排序的核心就是把记录按下标的一定**增量**分组，对每组使用直接插入排序算法排序，所以选择合适的增量序列直接影响了排序的效率。

### 增量序列

* 原始希尔排序的增量序列：length / 2， 向下取整
* Hibbard增量序列：2k - 1，即 1, 3, 5, 7, 9 ···
* Knuth增量序列：3k + 1，即 1, 4, 13, 40 ···
* Sedgewick增量序列：[1, 5, 19, 41, 109, 209, 505, 929, 2161...] 即9 * 4^i - 9 * 2^i + 1和4^i−3*2^i+1两个公式的正数解的正序合集 


## 快速排序

快速排序算法由 C. A. R. Hoare 在 1960 年提出。它的时间复杂度也是O(nlogn), 在几种时间复杂度为O(nlogn)级的排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。

### 快速排序的基本思想

1. 从数组中取出一个数，称之为基数（pivot）
2. 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域
3. 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成


### 基数的选择

* 最简单的办法就是用数组的第一个元素
但是这个做法在对反序数组进行排序的效率并不高

* 第2种方式就是利用随机函数在数组中随机取一个数作为基数，这样每轮都选到最大或最小值的概率就会变得很低了, 但是缺点是随机函数也是消耗性能的，所以并不算最优解

* 第3种方式像是第一种和第二种方式的混合，利用洗牌算法把原数据打乱，再取第一个元素作为基数，本质上还是为了**避免每轮都选到最大或最小值**，但是缺点和第二种方式一样

通过以上几种方式我们可以知道**免避基数是最大或最小值, 使基数两边的分区均匀分布**的同时，避免额外调用函数，快速排序的效率最高。

**所以还有一种比较好的取基数方式是，取头中尾三个位置的值的中间数作为基数, 这样可以避免基数是最大最小值，且取三个数的中间数消耗的性能也比洗牌或者随机选择的函数更少**

